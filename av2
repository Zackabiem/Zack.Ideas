import os
import time
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization, hashes, padding as sym_padding
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend

# === CONFIGURABLE PARAMETERS ===
RANSOM_EXTENSION = '.beljuza'
PRIVATE_KEY_PATH = 'private.pem'

def find_encrypted_files(base_path):
    """Recursively find all .beljuza files."""
    result = []
    for root, dirs, files in os.walk(base_path):
        for file in files:
            if file.endswith(RANSOM_EXTENSION):
                result.append(os.path.join(root, file))
    return result

def get_orig_timestamp(encrypted_path):
    """Try to find and return the original file's timestamp (if saved) or use .beljuza file's time."""
    # In this version, we use the encrypted file's mtime as the original timestamp
    try:
        stat = os.stat(encrypted_path)
        return stat.st_mtime
    except Exception:
        return None

def decrypt_file(filepath, private_key):
    """
    Decrypt a file:
    [encrypted_key (RSA-encrypted 32 bytes)] + [iv (16 bytes)] + [encrypted_data]
    Returns: (decrypted_bytes, orig_path, orig_timestamp) or None
    """
    try:
        with open(filepath, 'rb') as f:
            encrypted_key = f.read(512)     # 4096-bit RSA = 512 bytes, adjust if using different key length
            iv = f.read(16)
            encrypted_data = f.read()
        # Decrypt AES key with private key
        aes_key = private_key.decrypt(
            encrypted_key,
            padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)
        )
        # Decrypt file data
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(encrypted_data) + decryptor.finalize()
        # Unpad data
        unpadder = sym_padding.PKCS7(128).unpadder()
        data = unpadder.update(padded_data) + unpadder.finalize()
        # Figure out original file path
        orig_path = filepath[:-len(RANSOM_EXTENSION)]
        orig_timestamp = get_orig_timestamp(filepath)
        return data, orig_path, orig_timestamp
    except Exception as e:
        return None, None, None, str(e)

def remove_ransom_notes(base_path):
    """Remove ransom notes from all directories. Returns count of notes removed."""
    removed = 0
    for root, dirs, files in os.walk(base_path):
        note_path = os.path.join(root, 'BELJUZA_README.txt')
        if os.path.exists(note_path):
            try:
                os.remove(note_path)
                removed += 1
            except Exception:
                pass
    return removed

def main(base_path):
    # Load private key
    with open(PRIVATE_KEY_PATH, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password=None,
            backend=default_backend()
        )
    files = find_encrypted_files(base_path)

    print(f"Found {len(files)} encrypted files to process.\n")
    total_bytes = 0
    files_decrypted = 0
    errors = []

    for fpath in files:
        data, orig_path, orig_timestamp, *err = decrypt_file(fpath, private_key)
        if data and orig_path:
            try:
                with open(orig_path, 'wb') as f:
                    f.write(data)
                # Restore timestamp
                if orig_timestamp:
                    os.utime(orig_path, (orig_timestamp, orig_timestamp))
                size = len(data)
                total_bytes += size
                files_decrypted += 1
                os.remove(fpath)
                print(f"Decrypted: {fpath} -> {orig_path} ({size} bytes)")
            except Exception as e:
                errors.append((fpath, str(e)))
                print(f"Error restoring {fpath}: {e}")
        else:
            msg = err[0] if err else "Unknown error"
            errors.append((fpath, msg))
            print(f"Failed to decrypt {fpath}: {msg}")

    ransom_notes_removed = remove_ransom_notes(base_path)

    print("\n==== DECRYPTION STATS ====")
    print(f"Files decrypted: {files_decrypted}")
    print(f"Total bytes restored: {total_bytes}")
    print(f"Ransom notes removed: {ransom_notes_removed}")
    print(f"Errors encountered: {len(errors)}")
    if errors:
        for fname, emsg in errors:
            print(f"  {fname}: {emsg}")

if __name__ == "__main__":
    # Change to your desired root if needed
    main(os.path.expanduser("~"))